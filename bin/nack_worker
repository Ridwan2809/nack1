#!/usr/bin/env ruby

require 'optparse'

options = {}

opts = OptionParser.new("", 24, '  ') { |opts|
  opts.banner = "Usage: nack_worker [options] [rackup config]"

  opts.on("-f", "--file SOCKET", "listen on SOCKET") { |file|
    options[:file] = File.expand_path(file)
  }

  opts.on("--pipe PIPE", "ready pipe") { |pipe|
    options[:pipe] = File.expand_path(pipe)
  }

  opts.parse! ARGV
}

config = ARGV[0] || "config.ru"

if !File.exist?(config)
  abort "configuration #{config} not found"
end

if !options[:file]
  abort "need a socket path"
end

abort_with_exception = lambda do |e|
  if File.exist?(options[:file])
    File.unlink options[:file]
  end

  if options[:pipe] && File.pipe?(options[:pipe])
    exception = {
      :name    => e.class.name,
      :message => e.message,
      :stack   => e.backtrace.join("\n")
    }

    a = open(options[:pipe], 'w')

    if exception.respond_to?(:to_json)
      a.write exception.to_json
    else
      a.write <<-JSON
        { "name": #{exception[:name].inspect},
          "message": #{exception[:message].inspect},
          "stack": #{exception[:stack].inspect} }
      JSON
    end

    a.close

    File.unlink options[:pipe]
  end

  exit 1
end

# Explicitly load json before application
begin
  require 'json'
rescue LoadError
  begin
    require 'rubygems'
    require 'json'
  rescue LoadError => e
    abort_with_exception[e]
  end
end

begin
  require 'nack/builder'
  cfgfile = File.read(config)
  app = eval("Nack::Builder.new {( #{cfgfile}\n )}.to_app", nil, config)
rescue Exception => e
  abort_with_exception[e]
end

options[:name] = File.basename(File.dirname(config))

require 'nack/server'
Nack::Server.run(app, options)
